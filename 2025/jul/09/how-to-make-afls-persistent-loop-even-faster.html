<!DOCTYPE html><html prefix="og: https://ogp.me/ns#"lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width, initial-scale=1.0"><meta name=keywords content="fuzzing, afl, research"><meta name=description content="How to make AFL++'s persistent loop even faster"><meta name=author content=z2><meta property=og:title content="How to make AFL++'s persistent loop even faster"><meta property=og:type content=article><meta property=article:author content=https://github.com/z2-2z><meta property=og:site_name content="z2's blog"><meta property=og:url content=/2025/jul/09/how-to-make-afls-persistent-loop-even-faster.html><meta property=og:description content="z2's blog"><meta property=og:image content=https://z2-2z.github.io/img/og-image.webp><meta property=og:image:width content=1280><meta property=og:image:height content=720><meta property=og:image:type content=image/png><meta name=twitter:card content=summary_large_image><meta name=twitter:site content=@_z2_2z_><meta name=twitter:creator content=@_z2_2z_><meta name=twitter:title content="How to make AFL++'s persistent loop even faster"><meta name=twitter:description content="z2's blog"><meta name=twitter:image content=https://z2-2z.github.io/img/og-image.webp><title>How to make AFL++'s persistent loop even faster</title><link rel=stylesheet href=/css/normalize.min.css><link rel=stylesheet href=/css/common.min.css><link rel=stylesheet href=/css/post.min.css><link href=/atom.xml type=application/atom+xml rel=alternate title="Atom feed"><style>@font-face{font-family:CodeFont;src:url(/fonts/code.woff2)format("woff2");font-weight:400;font-style:normal;font-display:block}</style><link rel=preload href=/css/atom-one-dark.min.css as=style onload=this.onload=null;this.rel='stylesheet'><noscript><link rel=stylesheet href=/css/atom-one-dark.min.css></noscript><script src=/js/highlight.min.js defer></script><script>document.addEventListener(`DOMContentLoaded`,()=>{hljs.highlightAll()})</script><script src=/js/hljs/c.min.js defer></script><body><div id=container><div id=item><div id=headline><h1>How to make AFL++'s persistent loop even faster</h1><div id=metadata><div id=categories><span class=category><a href=/archive.html?#category%3A%22fuzzing%22>#fuzzing</a></span><span class=category><a href=/archive.html?#category%3A%22afl%22>#afl</a></span><span class=category><a href=/archive.html?#category%3A%22research%22>#research</a></span></div><div id=date><span>09 jul 2025</span></div></div></div><ul><li>If you ever wanted to create the best possible harness for a program you are fuzzing, you surely have considered to use AFL's persistent mode<li>It is supposed to be the "most effective way to fuzz" and can give a 20x speed boost over a forkserver <span class=quote>[<a href=#reference-1>1</a>]</span> but if we take a look at the implementation we can see that it is not optimal and has room for improvements<li>So, this blog post is gonna be about how to optimize the persistent loop and make it as minimal as possible<li>The end result cuts 75% of the kernel-time overhead and gave me, personally, a 15% speed increase in the targets I fuzzed<li>I consider these pretty good results so I want to share my approach here<li>You can find the code for everything that we're gonna talk about here: ?</ul><h2><a href=#how-afl39s-persistent-mode-works><span id=how-afl39s-persistent-mode-works>How AFL++'s persistent mode works</span></a></h2><ul><li>The persistent mode is just a small modification of the standard forkserver protocol<li>The forkserver implementation gets compiled into the target by <code class="hljs code-inline">afl-cc</code> and gets invoked by the <code class="hljs code-inline">__AFL_INIT()</code> macro<li>It looks like this:</ul><p><div class=figure id=figure-1><a href=./afl-forkserver.svg target=_blank> <img loading=lazy src=./afl-forkserver.svg> </a><p><a href=#figure-1> <span class=slightly-bold>Figure 1: </span> </a> Timeline of AFL's forkserver protocol <span class=quote>[<a href=#reference-2>2</a>]</span></div><p></p><br class=blank-line><ul><li>We can see that there are three processes involved</ul><ol><li>the fuzzer "afl-fuzz" that executes the target<li>the target that jumps into the forkserver code whenever <code class="hljs code-inline">__AFL_INIT()</code> is hit<li>and the target after <code class="hljs code-inline">__AFL_INIT()</code>, processing input and getting fuzzed</ol><ul><li>first we have a handshake where the forkserver communicates certain configurations to the fuzzer process<li>then we have the forkserver loop, enclosed in dotted lines, that repeats endlessly<li>It spins off the target and waits until its completion</ul><br class=blank-line><ul><li>If we want to analyze the performance of this protocol, we have to look at the biggest cost factor in its implementation and that is the overhead introduced by system calls<li>system calls do not only steal execution time from userland code but they also increase contention and decrease scalability when we are fuzzing on multiple cores <span class=quote>[<a href=#reference-3>3</a>]</span><li>Thus it is very important to minimize all system calls</ul><br class=blank-line><ul><li>The communication between afl-fuzz and the forkserver is realized via <a class=link href=https://www.man7.org/linux/man-pages/man2/pipe.2.html target=_blank>pipes</a> and every arrow between <code class="hljs code-inline">afl-fuzz</code> and <code class="hljs code-inline">target (forkserver)</code> represents either a <code class="hljs code-inline">read()</code> or a <code class="hljs code-inline">write()</code> to a pipe<li>This gives us a total of 5 system calls for one execution of the target: 1x <code class="hljs code-inline">read()</code>, 2x <code class="hljs code-inline">write()</code>, 1x <code class="hljs code-inline">fork()</code>, 1x <code class="hljs code-inline">waitpid()</code><li>It turns out that the most overhead comes from the management of child processes: <code class="hljs code-inline">fork()</code> and <code class="hljs code-inline">waitpid()</code><li>Or more specifically: Creating and tearing down the <code class="hljs code-inline">target</code> process<li>To be fair: The overhead of <code class="hljs code-inline">fork()</code> is quite moderate <span class=quote>[<a href=#reference-4>4</a>]</span>, the most expensive part is the teardown of a process by the kernel<li>Especially when sanitizers are involved, research has shown that just the <code class="hljs code-inline">exit()</code> system call takes up ~30% of the total execution time <span class=quote>[<a href=#reference-5>5</a>]</span><li>So how do we improve the performance of the forkserver?<li>By simply not exiting.</ul><br class=blank-line><ul><li>The persistent mode works by inserting a loop into the target like this...</ul><pre class=code-block><code class="hljs language-c">__AFL_INIT();

while (__AFL_LOOP(12345)) {

}
</code></pre><ul><li>...where in every new iteration you get a new input from the fuzzer</ul><h2><a href=#how-to-improve><span id=how-to-improve>How to improve</span></a></h2><h2><a href=#how-to-use-the-library><span id=how-to-use-the-library>How to use the library</span></a></h2><h2><a href=#references><span id=references>References</span></a></h2><table id=citations><tr id=reference-1><td class=cite-number>[1]<td class=cite-source><a class=link href=https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.persistent_mode.md target=_blank>AFL++ docs: llvm_mode persistent mode</a><tr id=reference-2><td class=cite-number>[2]<td class=cite-source><a class=link href=https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/afl-compiler-rt.o.c target=_blank>afl-compiler-rt.o.c</a><tr id=reference-3><td class=cite-number>[3]<td class=cite-source><a class=link href=https://gts3.org/assets/papers/2017/xu:os-fuzz.pdf target=_blank>Designing New Operating Primitives to Improve Fuzzing Performance</a><tr id=reference-4><td class=cite-number>[4]<td class=cite-source><a class=link href=https://lcamtuf.blogspot.com/2015/06/new-in-afl-persistent-mode.html target=_blank>New in AFL: persistent mode</a><tr id=reference-5><td class=cite-number>[5]<td class=cite-source><a class=link href=https://hexhive.epfl.ch/publications/files/20ATC.pdf target=_blank>FuZZan: Efficient Sanitizer Metadata Design for Fuzzing</a></table><hr><div id=footer-meta><span id=footer-blog><a href=/>z2's blog</a></span></div><br></div></div>