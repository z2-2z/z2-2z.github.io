<!DOCTYPE html><html><head><meta charset=UTF-8><title>DownUnderCTF: My first echo server</title><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/common.css><link rel=stylesheet href=/css/post.css><link rel=stylesheet href=/css/atom-one-dark.min.css><script src=/js/highlight.min.js></script><script>document.addEventListener("DOMContentLoaded",()=>{hljs.highlightAll()})</script><script src=/js/hljs/plaintext.min.js></script><body><div id=container><div id=item><h1>DownUnderCTF: My first echo server</h1><div id=metadata><div id=categories><span class=category><a href=/?#category%3A%22ctf%22>#ctf</a></span><span class=category><a href=/?#category%3A%22writeup%22>#writeup</a></span><span class=category><a href=/?#category%3A%22pwn%22>#pwn</a></span></div><div id=date><span>20 sep. 2020</span></div></div><p><b>Category</b>: Pwn<br><b>Points</b>: 416<br><b>Challenge Binary</b>: <a class=link href=./echos target=_blank>echos</a></p><br><div class=blockquote><p>Hello there! I learnt C last week and already made my own SaaS product, check it out! I even made sure not to use compiler flags like --please-make-me-extremely-insecure, so everything should be swell.<br><br><code class="hljs code-inline">nc chal.duc.tf 30001</code><br><br>Hint - The challenge server is running Ubuntu 18.04.</div><h2 id=challenge-overview><a href=#challenge-overview>Challenge Overview</a></h2><p>This challenge was pretty straightforward: You can control a format-string in 3 subsequent calls to printf.<br><br><p><div class=figure id=figure-1><a href=./main.png target=_blank> <img loading=lazy src=./main.png> </a><p><a href=#figure-1> <span class=slightly-bold>Figure 1:</span> Disassembly of <code class="hljs code-inline">main()</code> </a></div><p><h2 id=exploit-overview><a href=#exploit-overview>Exploit Overview</a></h2><p>My exploit strategy was as follows:<br><br><ol><li>Leak libc address<li>Overwrite <code class="hljs code-inline">__malloc_hook</code><li>Trigger <code class="hljs code-inline">malloc()</code> inside <code class="hljs code-inline">printf()</code></ol><br><p>But first we needed to find the correct libc because "Ubuntu 18.04" is a bit vague. To do that leak the saved basepointer of main() and (apparently) substract 2192 from it to get the base address of the binary. After that you can leak some .got values with <code class="hljs code-inline">%X$s</code> where argument number <code class="hljs code-inline">X</code> contains the address. I went for <code class="hljs code-inline">printf</code> and <code class="hljs code-inline">setvbuf</code>:<br><br><pre class=code-block><code class="hljs language-plaintext">[*] printf @ 0x7fb56b96ee80
[*] setvbuf @ 0x7fb56b98b2f0
</code></pre><br><p>Entering the offsets into a <a class=link href=https://libc.rip target=_blank>libc-database</a> yielded that the libc in use is libc6_2.27-3ubuntu1_amd64. This step is actually important because if you go to packages.ubuntu.com directly and download the libc6-package for bionic you will get another libc which won't work.<h2 id=leak-libc-address><a href=#leak-libc-address>Leak libc address</a></h2><p>This can be done by leaking the return-address of <code class="hljs code-inline">main()</code>. The stackframe of main() looks like this:<br><br><p><div id=table-1 class=table><table><thead><td>rbp-Offset<td>Content<td>printf argument #</thead><tr><td>+8<td>Return address<td>19<tr><td>0<td>Saved Basepointer<td>18<tr><td>-8<td>Canary<td>17<tr><td>-16<td>(Padding)<td>16<tr><td>-80<td>input buffer<td>8 - 15<tr><td>-96<td>(Padding)<td>6 - 7</table><p class=table-description><a href=#table-1> <span class=slightly-bold>Table 1:</span> Stackframe of <code class="hljs code-inline">main()</code> </a></div><br><p>The argument indices start at 6 because the ABI dictates that the first 6 arguments go into some registers. The first argument is the format-string leaving 5 registers for printf arguments. Those would have printf argument numbers 1 - 5. Thus the format string for leaking libc is: <code class="hljs code-inline">%19$lx</code>.<h2 id=overwrite-mallochook><a href=#overwrite-mallochook>Overwrite __malloc_hook</a></h2><p><a class=link href=https://www.man7.org/linux/man-pages/man3/malloc_hook.3.html target=_blank>malloc_hook(3)</a> is a special variable inside glibc that lets you override default malloc-behaviour. When malloc is called it checks whether this variable is set and transfers control to the hook if so. So effectively it is a function pointer. The format-string that can overwrite the hook is based on <code class="hljs code-inline">%n</code>, must be constructed dynamically though. See <a class=link href=./exploit.py target=_blank>exploit.py</a> for more details on how to construct such a format-string.<h2 id=trigger-malloc-inside-printf><a href=#trigger-malloc-inside-printf>Trigger malloc inside printf</a></h2><p>This can be done by causing a huge output like <code class="hljs code-inline">%65510c</code> or <code class="hljs code-inline">%90000c</code>.<h2 id=flag><a href=#flag>Flag</a></h2><pre class=code-block><code class="hljs language-plaintext">DUCTF{D@N6340U$_AF_F0RMAT_STTR1NG$}
</code></pre><br><hr><div id=footer-meta><span id=footer-blog>( <a href=/>z2's blog</a> )</span></div><br></div></div><img id=tracker width=1 height=1 src=https://in.getclicky.com/101440355ns.gif>