<!DOCTYPE html><html><head><meta charset=UTF-8><title>DawgCTF: Where we roppin boys?</title><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/common.css><link rel=stylesheet href=/css/post.css><link rel=stylesheet href=/css/atom-one-dark.min.css><script src=/js/highlight.min.js></script><script>document.addEventListener("DOMContentLoaded",()=>{hljs.highlightAll()})</script><script src=/js/hljs/plaintext.min.js></script><script async data-id=101440355 src=https://static.getclicky.com/js></script><body><div id=container><div id=item><h1>DawgCTF: Where we roppin boys?</h1><div id=metadata><div id=categories><span class=category><a href=/?#category%3A%22ctf%22>#ctf</a></span><span class=category><a href=/?#category%3A%22writeup%22>#writeup</a></span><span class=category><a href=/?#category%3A%22pwn%22>#pwn</a></span></div><div id=date><span>16 apr. 2020</span></div></div><div class=blockquote><p>Forknife is still a thing right?<p><code class="hljs code-inline">nc ctf.umbccd.io 4100</code></div><br><p><b>Category</b>: pwn<br><b>Points</b>: 350<br><b>Author</b>: trashcanna<br><b>Challenge Binary</b>: <a class=link href=./rop target=_blank>rop</a><h2 id=overview><a href=#overview>Overview</a></h2><p>We were given a 32-bit executable with canaries and PIE disabled.The main functionality of the binary includes only 3 small functions:<br><br><div class=figure id=figure-1><a href=./functions.png target=_blank> <img loading=lazy src=./functions.png> </a><p><a href=#figure-1> <span class=slightly-bold>Figure 1:</span> Disassembly of challenge binary </a></div><p><br><br>The vulnerability is highlighted in red. <code class="hljs code-inline">tryme</code> stores up to 25 bytesinto an 8-byte buffer leading to a classical stack-buffer overflow. Unfortunately 25 bytes allow only very limited exploitation, in fact if we look at the stackframe of <code class="hljs code-inline">tryme</code> the overflow allows us to placea maximum of only 2 ROP-gadgets.<p><div id=table-1 class=table><table><thead><td>Offset<td>Content<td>Size</thead><tr><td>-0x4<td>Return pointer<td>4<tr><td>-0x8<td>Saved ebp<td>4<tr><td>-0xc<td>Saved ebx<td>4<tr><td>-0x14<td>input<td>8</table><p class=table-description><a href=#table-1> <span class=slightly-bold>Table 1:</span> Stackframe of <code class="hljs code-inline">tryme</code> </a></div><h2 id=hidden-functionalities><a href=#hidden-functionalities>Hidden Functionalities</a></h2><p>Looking at the symbol table we can see that the binary contains a lot of functionsthat don't get called:<br><br><div class=figure id=figure-2><a href=./hidden.png target=_blank> <img loading=lazy src=./hidden.png> </a><p><a href=#figure-2> <span class=slightly-bold>Figure 2:</span> Symbol table excerpt </a></div><p><br><p>The first 7 functions set the shellcode up, which was mmaped earlier in <code class="hljs code-inline">welcome</code>. Each of these functions appends 4 specific bytes to the shellcode. The last function <code class="hljs code-inline">win</code> takes the shellcode and executes it. After puzzling a bit we can get the following shellcode:<br><br><pre class=code-block><code class="hljs language-plaintext">0:    31 c0                   xor    eax, eax
2:    50                      push   eax
3:    68 2f 2f 73 68          push   0x68732f2f
8:    68 2f 62 69 6e          push   0x6e69622f
d:    89 e3                   mov    ebx, esp
f:    89 c1                   mov    ecx, eax
11:   89 c2                   mov    edx, eax
13:   b0 0b                   mov    al, 0xb
15:   cd 80                   int    0x80
17:   31 c0                   xor    eax, eax
19:   40                      inc    eax
1a:   cd 80                   int    0x80
</code></pre><br><p>with the following order:<br><br><ol><li>tilted_towers<li>junk_junction<li>snobby_shores<li>greasy_grove<li>lonely_lodge<li>dusty_depot<li>loot_lake</ol><br><p>So our task is to create a ROP-chain that calls these 7 functions in exactly that order followed by a call to <code class="hljs code-inline">win</code> to get a shell. But we can place only 2 ROP-gadgets so how do we execute 8?<h2 id=expanding-our-possibilities><a href=#expanding-our-possibilities>Expanding our possibilities</a></h2><p>If we take a look at the disassembly of <code class="hljs code-inline">main</code>:<br><br><div class=figure id=figure-3><a href=./main.png target=_blank> <img loading=lazy src=./main.png> </a><p><a href=#figure-3> <span class=slightly-bold>Figure 3:</span> Disassembly of <code class="hljs code-inline">main</code> </a></div><p><br>We can see that a <code class="hljs code-inline">CALL tryme</code> follows an <code class="hljs code-inline">AND ESP, 0xfffffff0</code>. If we take the stackframe of <code class="hljs code-inline">tryme</code> from above and add some stack addresses we get the following stack layout (where <i>x</i> stands for a random byte):<br><br><p><div id=table-2 class=table><table><thead><td>Address<td>Offset<td>Content<td>Size</thead><tr><td><i>xxxxxxx</i>0<td>-0x0<td>Aligned by <code class="hljs code-inline">main</code><td><tr><td><i>xxxxxxx</i>C<td>-0x4<td>Return pointer<td>4<tr><td><i>xxxxxxx</i>8<td>-0x8<td>Saved ebp<td>4<tr><td><i>xxxxxxx</i>4<td>-0xc<td>Saved ebx<td>4<tr><td><i>xxxxxxx</i>0<td>-0x10<td>input + 4<td>4<tr><td><i>xxxxxxx</i>C<td>-0x14<td>input + 0<td>4</table><p class=table-description><a href=#table-2> <span class=slightly-bold>Table 2:</span> Stackframe with addresses </a></div><br><p>If we now overwrite the return pointer of <code class="hljs code-inline">tryme</code> with the address of <code class="hljs code-inline">main</code> (0x08049714) we can cause a second alignment, this time at address <i>xxxxxxx</i>C moving the stack pointer all the way down to <code class="hljs code-inline">input + 4</code> preserving everything else in <code class="hljs code-inline">tryme</code>'s stackframe. After that <code class="hljs code-inline">main</code> calls <code class="hljs code-inline">tryme</code> again overwriting <code class="hljs code-inline">input + 0</code> with the return address for <code class="hljs code-inline">tryme</code>. We then have <i>again</i> the possibility to do a buffer-overflow. If we repeat this we can allocate multiple stackframes that are directly adjacent to each other. This is the setup for our ROP-chain.<h2 id=crafting-an-exploit><a href=#crafting-an-exploit>Crafting an exploit</a></h2><p>The exploit strategy is to create the following stack layout by repeatedly calling main through the buffer-overflows:<br><br><p><div id=table-3 class=table><table><thead><td>Offset<td>Stackframe Layout<td>Size<td>ROP-gadget<td>Nesting Level</thead><tr><td>-0x0<td>Aligned by <code class="hljs code-inline">main</code><td>4<td><b>win()</b><td>main<tr><td>-0x4<td>Return pointer<td>4<td>main()<td>1. tryme<tr><td>-0x8<td>Saved ebp<td>4<td><i>garbage</i><td>1. tryme<tr><td>-0xC<td>Saved ebx<td>4<td>pop ebx; pop ebp<td>1. tryme<tr><td>-0x10<td>input + 4<td>4<td><i>garbage</i><td>1. tryme<tr><td>-0x14<td>input + 0 / Return Pointer<td>4<td>main()<td>1./2. tryme<tr><td><td><td><td><td><tr><td>-0x18<td>Saved ebp<td>4<td>pop ebx; pop ebp<td>2. tryme<tr><td>-0x1C<td>Saved ebx<td>4<td><b>dusty_depot()</b><td>2. tryme<tr><td>-0x20<td>input + 4<td>4<td><i>garbage</i><td>2. tryme<tr><td>-0x24<td>input + 0 / Return Pointer<td>4<td>main()<td>2./3. tryme<tr><td><td><td><td><td><tr><td>-0x28<td>Saved ebp<td>4<td>pop ebx; pop ebp<td>3. tryme<tr><td>-0x2C<td>Saved ebx<td>4<td><b>lonely_lodge()</b><td>3. tryme<tr><td>-0x30<td>input + 4<td>4<td><i>garbage</i><td>3. tryme<tr><td>-0x34<td>input + 0 / Return Pointer<td>4<td>main()<td>3./4. tryme<tr><td>...<td>...<td>...<td>...<td>...<tr><td>-0x74<td>input + 0 / Return Pointer<td>4<td>pop ebx<td>7./8. tryme<tr><td>-0x78<td>Saved ebp<td>4<td><i>garbage</i><td>8. tryme<tr><td>-0x7C<td>Saved ebx<td>4<td><i>garbage</i><td>8. tryme<tr><td>-0x84<td>input<td>8<td><i>garbage</i><td>8. tryme</table><p class=table-description><a href=#table-3> <span class=slightly-bold>Table 3:</span> Final ROP-chain </a></div><br><p>Note how here the last function before <code class="hljs code-inline">win</code> is <code class="hljs code-inline">dusty_depot</code> and not <code class="hljs code-inline">loot_lake</code> because if you leave out the last 4 bytes of the shellcode you still get a valid execve() and this makes the ROP-chain a bit shorter.<h2 id=profit><a href=#profit>Profit</a></h2><p><a class=link href=./exploit.py target=_blank>exploit.py</a> executes the exploit as described above and we get<br><br><pre class=code-block><code class="hljs language-">DawgCTF{f0rtni9ht_xD}
</code></pre><br><hr><div id=footer-meta><span id=footer-blog>( <a href=/>z2's blog</a> )</span></div><br></div></div><noscript><img id=tracker width=1 height=1 src=https://in.getclicky.com/101440355ns.gif></noscript>