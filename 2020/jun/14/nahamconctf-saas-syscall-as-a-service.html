<!DOCTYPE html><html><head><meta charset=UTF-8><title>NahamconCTF: SaaS - Syscall as a Service</title><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/common.css><link rel=stylesheet href=/css/post.css><link rel=stylesheet href=/css/atom-one-dark.min.css><script src=/js/highlight.min.js></script><script>document.addEventListener("DOMContentLoaded",()=>{hljs.highlightAll()})</script><script src=/js/hljs/plaintext.min.js></script><script src=/js/hljs/c.min.js></script><body><div id=container><div id=item><h1>NahamconCTF: SaaS - Syscall as a Service</h1><div id=metadata><div id=categories><span class=category>#ctf</span><span class=category>#writeup</span><span class=category>#pwn</span></div><div id=date><span>14 jun. 2020</span></div></div><p><b>Category</b>: pwn<br><b>Points</b>: 100<br><b>Challenge Binary</b>: <a class=link href=./saas target=_blank>saas</a><br><br><div class=blockquote><p>You've heard of software as a service, but have you heard of syscall as a service?</div><h2 id=overview><a href=#overview>Overview</a></h2><p>The program lets us make arbitrary amd64 system calls except:<ul><li>sys_execve<li>sys_fork<li>sys_clone<li>sys_kill<li>sys_ptrace<li>sys_tkill<li>stub_execveat</ul><br><p>The return value of the system call is echoed back to the user. Also the binary has all protections enabled:<br><br><pre class=code-block><code class="hljs language-plaintext">RELRO           STACK CANARY      NX            PIE             RPATH      RUNPATH      Symbols         FORTIFY Fortified       Fortifiable  FILE
Full RELRO      Canary found      NX enabled    PIE enabled     No RPATH   No RUNPATH   77 Symbols     Yes      0               1       saas
</code></pre><h2 id=exploit-strategy><a href=#exploit-strategy>Exploit Strategy</a></h2><p>If the binary wouldn't be position independent, executing shellcode would be trivial: Just mark the text-segment as writable with mprotect() and overwrite .text with our shellcode. Unfortunately we are completely blind. As the other writeups show, we can use mmap() to get our data into the process. Since mmap() can create executable regions we can use this to store shellcode that pops a shell (see <a class=link href=./shellcode.asm target=_blank>shellcode.asm</a>).<br>The only question that remains is: How do we get control over the instruction pointer with system calls? And that's where signals come in handy! If we manage to recrate the following code snippet we can get full code execution:<br><br><pre class=code-block><code class="hljs language-c">void* shellcode = mmap(NULL, 0x1337, PROT_READ | PROT_WRITE | PROT_EXECUTE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
read(0, shellcode, 0x1337);
signal(SIGHUP, shellcode);
raise(SIGHUP);
</code></pre><br><p>Note that SIGHUP is chosen arbitrarily. We can use any other signal.<h2 id=installing-a-signal-handler><a href=#installing-a-signal-handler>Installing a Signal Handler</a></h2><p>Let's recreate<br><br><pre class=code-block><code class="hljs language-c">signal(SIGHUP, shellcode)
</code></pre><br><p>with some system calls.<br>The system call that installs a signal handler is <code class="hljs code-inline">sys_rt_sigaction</code> (number 13). It takes the following arguments:<br><br><p><div class=figure id=figure-1><a href=./rt_sigaction.png target=_blank> <img loading=lazy src=./rt_sigaction.png> </a><p><a href=#figure-1> <span class=slightly-bold>Figure 1:</span> Arguments of <code class="hljs code-inline">sigaction</code> syscall </a></div><p></p><br><p>The <code class="hljs code-inline">struct sigaction</code> looks like this:<br><br><pre class=code-block><code class="hljs language-c">struct kernel_sigaction
{
    __sighandler_t k_sa_handler;
    unsigned long sa_flags;
    void (*sa_restorer) (void);
    sigset_t sa_mask;
};
</code></pre><br><p><code class="hljs code-inline">k_sa_handler</code> is the handler function for the signal. This will be the address of our shellcode. <code class="hljs code-inline">sa_flags</code> and <code class="hljs code-inline">sa_mask</code> will be 0 since we don't want any special behaviour. <code class="hljs code-inline">sa_restorer</code> normally contains a pointer to a function that restores the state of the process right before the signal handler was executed. This is where sigreturn normally comes into play. In our case this field doesn't matter because execve will replace the process anyway but in the exploit script I set this to the address of our shellcode. <code class="hljs code-inline">oact</code> also doesn't matter and can be NULL and <code class="hljs code-inline">sigsetsize</code> is 8.<h2 id=delivering-a-signal><a href=#delivering-a-signal>Delivering a signal</a></h2><p>I chose to deliver a signal with the <code class="hljs code-inline">sys_tgkill</code> system call (number 234). This system call just takes a process id and a signal and delivers that signal to the process. Nothing special.<h2 id=crafting-the-exploit><a href=#crafting-the-exploit>Crafting the exploit</a></h2><p>We can now combine everything into following exploit:<br><br><ol><li>mmap() a region for our shellcode (must be executable)<li>Write our shellcode into the region<li>mmap() a region for the <code class="hljs code-inline">struct sigaction</code><li>Write the following values into it:<ul><li><code class="hljs code-inline">k_sa_handler</code> = shellcode<li><code class="hljs code-inline">sa_flags</code> = 0<li><code class="hljs code-inline">sa_restorer</code> = shellcode (but doesn't matter really)<li><code class="hljs code-inline">sa_mask</code> = 0</ul><li>Install the signal handler<li>Deliver the signal</ol><br><p>See <a class=link href=./exploit.py target=_blank>exploit.py</a> for a concrete implementation.<br><br></div></div>